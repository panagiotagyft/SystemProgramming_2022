
Κ24 ΠΡΟΓΡΑΜΜΑΤΙΣΜΟΣ ΣΥΣΤΗΜΑΤΟΣ:  1η Άσκηση

Παναγιώτα Γύφτου,     Α.Μ. 1115201900318

Θα ήθελα να σας ενημερώσω ότι για την ουρά έχω χρησιμοποιήσει άσκηση από το μάθημα το Δομών Δεδομένων, είναι μια υλοποίηση ουράς διπλά συνδεδεμένης λίστας.Η άσκηση έχει γίνει εξ’ολοκλήρου από μένα.Τέλος τα ονόματα των συναρτήσεων είναι ίδια με αυτά που ζητούσε η εκφώνηση (και μόνο αυτά).Για οποιοδήποτε θέμα, εννοείται είμαι στην διάθεση σας.

---  Ζητούμενο 1:  ---

1.Οι εντολές μεταγλώττισης του προγράμματος βρίσκονται στο αρχείο Makefile, δηλαδή η    μεταγλώττιση γίνεται με το make.

2. Και τρέχω το πρόγραμμα: ./sniffer -p /home/users/sdi1900318/syspro ή απλά ./sniffer
  
3. -Περιγραφή Προγράμματος:
	Ξεκινάω την εκτέλεση του προγράμματος ,αρχικά ελέγχω αν μου δόθηκε path από τον χρήστη, αν ναι τότε αποθηκεύω την διαδρομή που θα παρακολουθεί ο Listener μέσω του εργαλείου inotifywait.Εάν δεν μου έχει δοθεί μονοπάτι ο Listener μέσω του εργαλείου inotifywait παρακολουθεί τον τρέχοντα κατάλογο.’Επειτα έχω τους signal handlers όπου ανάλογα με το σήμα, κάνουν την αντίστοιχη δουλεια, εδώ έχουμε δύο χειριστές , ο ένας για το σήμα SIGINT και ο δεύτερος για το σήμα SIGCHLD (στην συνέχεια αναλύεται η χρήση τους).Έπειτα δημιουργώ έναν φάκελο με το όνομα Producted_Files που θα τοποθετηθεί στον path όπου βρίσκεται και ο κώδικας.Στον φάκελο Producted_Files θα αποθηκευτούν τα αποτελέσματα των Worker.Ακολουθεί η δημιουργία της ουράς όπου θα αποθηκεύω τους ελευθερους Workers και τέλος δημιουργώ τους Listener- Manager-Workers.

Η υλοποίηση των οντοτήτων του Listener (ανιχνευτής) και του Manager γίνεται στο
αρχείο με  όνομα  Listener_Manager.c.Αρχικά με τη βοήθεια της κλήσης του συστήματος pipe() δημιουργώ τον αγωγό επικοινωνίας μεταξύ του Listener και του  Manager, έτσι ώστε όταν ο Listener ανιχνεύσει κάποια κίνηση αρχείου μέσα στον κατάλογο που του έχει ανατεθεί να  παρακολουθεί, να ενημερώνει τον Manager μέσω του pipe. Στην συνέχεια δημιουργώ τις οντότητες Listener και  Manager με την βοήθεια της κλήσης συστήματος fork(). Ως κεντρική οντότητα του συστήματος, τον Manager τον έχω ορίσει να έχει τον ρόλο του γονικής διεργασίας ενώ τον Listener να έχει της θυγατρικής.

	Ο Listener (θυγατρική διεργασία) λαμβάνει τιμή επιστροφής 0 από την fork(). Το πρώτο πράγμα που γίνεται στο σώμα του Listener είναι να κλείσει το άκρο αναγνωσης του αγωγού επικοινωνίας Listener-Manager (δηλαδή κλείνουμε τον περιγρραφέα αρχείου p_fd[0] που μας έδωσε η pipe() ) καθώς δεν το χρειάζεται.Στην συνέχεια με την κλήση dup2() διευθετώ το STDOUT_FILENO (την έξοδο) του Listener να αποτελεί το άκρο εγγραφής του αγωγού.Κλείνω και το άκρο εγγραφής του αγωγού που πλέον δεν χρειάζεται close(p_fd[1]).Τέλος ο Listener εκτελεί την execvp(), η οποία υποκαταστεί την εικόνα μνήμης με την εντολή συστήματος inotifywait.Ρυθμίζω την inotifywait να εκτελείται επάπειρον με την επιλογή -m, δηλαδή να μη τερματίσει όταν ανιχνεύσει ένα και μονο συμβάν, τα συμβάν που θελουμε να ανιχνεύει είναι η δημιουργία ή μετονομασία αρχείου -e creat και -e moved_to αντίστοιχα.Τέλος όπως είδαμε στην αρχή, αν ο χρήστης έδωσε διαδρομή παρακολούθησης κάποιου καταλόγου θα προσθέσουμε ολόκληρο το path στον inotifywait  αλλιώς με “.” του λέμε παρακολούθησε τον τρέχοντα κατάλογο.  

	Ο Manager (γονική διεργασία) αρχικά στο σώμα του κλείνει το άκρο εγγραφής του αγωγού, γιατί δεν του είναι χρήσιμος και αφήνει ανοιχτό το άκρο ανάγνωσης. Στην συνέχεια  ακολουθεί ένας ατέρμονος βρόχος, στον οποίο γίνεται η βασική λειτουργία  του Manager.Στην αρχή του ατέρμονου βρόχου εκτελείται ένα while loop, με το οποίο ο Manager διαβάζει τα μηνύματα που έχει στείλει ο Listener μέσω του αγωγού.Για την επίτευξη της ανάγνωσης του αγωγού καλείται η κλήση συστήματος read(), όπου την έχω προγραμματίσει να διαβάζει χαρακτήρα-χαρακτήρα ώστε ταυτόχρονα μέσα στο σώμα της while να αποθηκεύεται σε έναν πίνακα η χρήσιμη πληροφορία.Ο Listener στέλνει παραπάνω πληροφορία για το αρχείο που τον διέγειρε, δηλαδή αν το αρχείο προστέθηκε στον κατάλογο CREAT ή μετονομάστηκε MOVED_TO, εμάς όμως μας ενδιαφέρει μόνο το path του αρχείου.Στην συνέχεια έχοντας αποθηκεύσει την πληροφορία βγαίνουμε από το while loop και κάνουμε έναν έλεγχο αν το errno ισούται με την τιμή EINTR και η επιστρεφόμενη τιμή της read() είναι ίση με -1. Αυτός ο έλεγχος γίνεται για να δούμε αν η read() έχει μπλοκαριστεί εξαιτίας κάποιου σήματος, ώστε να την ξεμπλοκάρουμε, θα αναφερθώ ξανά πιο κάτω για την χρήση αυτής της συνθήκης στο σημείο όπου χρειάζεται και ενεργοποιείται.Έπειτα  έχοντας όπως είπα πιο πάνω ξεκινήσει το πρόγραμμα έχω δημιουργήσει μια ουρά διπλά συνδεδεμένης λίστας, ελέγχω αν αυτή η ουρά έχει αποθηκευμένους διαθέσιμους Workers που είναι σταματημένοι. Εαν η ουρά είναι κενή δημιουργώ ένα  καινούργιο Worker, ώστε να κάνει την εξαγωγή πληροφοριών του αρχείου.Πριν όμως δημιουργήσω τον Worker πρέπει να διασφαλίσω την επικοινωνία του Worker με τον Manager .Έτσι φτιάχνω έναν επώνυμο αγωγό για την επιτευξη επικοινωνίας μεταξύ αυτών των δύων οντοτήτων.Δημιουργώ επώνυμο αγωγό και όχι απλό για τον λόγο ότι μελλοντικά θα θέλουμε να ξαναχρησιμοποιήσουμε τον συγκεκριμένο Worker.Μετα την δημιουργία του named pipe (mkfifo() ) και το άνοιγμα του (open()), ο Manager γράφει στον αγωγό την πληροφορία που θέλει να διαβάσει ο Worker, δηλαδή στέλνει το path του αρχείου.Με μια fork() κλήση δημιουργώ τον Worker.Αν η επιστρεφόμενη τιμή της fork() είναι 0 τότε εκτελείται το σώμα του Worker.Την δουλειά του Worker την έχω υλοποιήσει στην συνάρτηση worker() που βρίσκεται στο αρχείο Worker.c.Τους Workers που δημιουργώ τους έχω αποθηκευμένους σε έναν πίνακα (pids[]).Αν είμαστε στην περίπτωση που η ουρά έχει διαθέσιμους Workers προς χρήση εξάγω τον πρώτο από την ουρά και τον σβήνω από αυτήν.Στην συνέχεια τον αφυπνίζω στέλνοντας τους μέσω της κλήσης kill() το σήμα SIGCONT. Ο Worker όταν τελειώσει την δουλειά του αυτο-μπλοκάρεται στέλνοντας μέσω της kill() στον εαυτό του το σήμα SIGSTOP (θα το αναλυσω στην περιγραφή του Worker).Με την συνάρτηση fifo_names() λαμβάνω το όνομα του επώνυμου αγωγού του συγκεκριμένου worker, τον ανοίγω με την κλήση συστήματος open() και γράφω στον αγωγό το path.Είναι ακριβώς η ίδια διαδικασία με πριν με τη διαφορά ότι εδώ δεν δημιουργώ έναν fifo αλλά χρησιμοποιώ έναν ήδη υπάρχον.Στο τέλος του βρόχου αρχικοποιώ τον πίνακα όπου αποθηκεύω το path για νέα χρήση.Τέλος ο Manager κλείνει το άκρο ανάγνωσης του αγωγού (Listener-Manger).

	Δουλειά του Worker είναι να ανοίγει τα αρχεία που του στέλνει ο Manager και να εξάγει τα locations που περιέχονται μέσα στο αρχείο.Ταυτόχρονα επεξεργάζεται τα locations και δημιουργεί ένα καινούριο αρχείο, στο οποίο γράφει τα locations που βρήκε μαζί με τον αριθμό των εμφανίσεων τους. Πιο αναλυτικά: Αρχικά αρχικοποιώ τρεις πίνακες όπου οι δύο πρώτοι είναι βοηθητικοί στην εξαγωγή των locations και ο τελευταίος (buf[]) αποθηκεύει το μήνυμα, δηλαδή το μονοπάτι που έστειλε ο Manager.Στη συνέχεια με την κλήση της open(), ανοίγω τον επώνυμο αγωγό (το όνομα του αγωγού το περνάω σαν όρισμα στην συνάρτηση worker(). Αφού ανοίξει ο Worker τον αγωγό, με την κλήση συστήματος read() διαβάζει το μήνυμα που έστειλε ο Manager μέσω του αγωγού.Στην συνέχεια βάζω τον Worker να κοιμηθεί για 5 δευτερόλεπτα, για τον λόγο ότι παρατήρησα ότι τα αρχεία που έστελνα από το pc μου στα μηχανήματα της σχολής δεν ήταν κατευθείαν εξ’ ολοκλήρου διαθέσιμα.Εκτός το ότι μπλόκαρε η read() επαληθεύτηκα και με την χρήση της lseek()  όπου μου επέστρεφε την τιμή 0 για το τέλος του αρχείου.Για την επιτευξη του ανοίγματος του αρχείου γίνεται η χρήση της κλήσης open().Στην συνέχεια με μια while loop  γίνεται η ανάγνωση του αρχείου χαρακτήρα-χαρακτήρα μέσω της read(), για να αποθηκευτεί η κατάλληλη πληροφορία.Συγκεκριμένα σε πρώτη φάση μέσα στον βρόχο while  ψάχνω να βρω τα urls με πρωτόκολλο http://, τότε απο ‘κει και κάτω σε δεύτερη φάση αποθηκεύω όλους τους χαρακτήρες μέχρι να συναντήσω τον χαρακτήρα ‘ / ’ ή το κενό ‘  ‘. Σε τρίτη φάση, ελέγχω αν αυτό που έχω αποθηκεύσει ως location ξεκινάει με την συμβολοσειρά www. , αν υπάρχει την αφαιρώ. Αφού έχω φιλτράρει το location , το προσθέτω (insert()) σε μια λίστα μαζί με τον αριθμό εμφάνισης του, αν αυτό δεν υπάρχει ήδη αποθηκευμένο (δηλαδή δεν έχει εμφανιστεί ξανά μέσα στο αρχείο).Εάν υπάρχει καταχωρημένο στην λίστα απλά αυξάνω τον μετρητή των εμφανίσεων του.Ο έλεγχος και η αύξηση του μετρητή γίνεται μέσω της συνάρτησης Update().Όταν τελειώσει ο Worker με την ανάγνωση του αρχείου δημιουργεί ένα αρχείο στο οποίο θα αποθηκεύσει τα locations που βρήκε με τον αριθμό των εμφανίσεων τους.Για την δημιουργία , αρχικά απομονώνει το όνομα του αρχείου από το path που έστειλε ο Manager ώστε να το χρησιμοποιήσει ως όνομα και στο νέο, και για να το πετύχει αυτό υπάρχει μια for loop όπου διαβάζει το path ανάποδα (αφού το όνομα του αρχείου που ανοίχθηκε αναγράφεται στο τέλος).Αφού έχει βρει το όνομα του αρχείου, στη συνέχεια διαμορφώνει την μορφή του, που θα είναι .out και τέλος δημιουργώ το path του, όπου θα βρίσκεται μέσα σε έναν ειδικό φάκελο που έχει δημιουργηθεί στην αρχή του προγράμματος (έχω αναφερθεί στην αρχή) με το όνομα Producted_Files (ο οποίος βρίσκεται στον φάκελο που είναι ο κώδικας).Μετά με έναν while βρόχο γράφει στο αρχείο που δημιουργησε τα locations με το πλήθος εμφάνισης τους, εξάγωντας τα από την λίστα μέσω της συνάρτησης get_location() και γράφοντας τα με την βοήθεια της κλήσης συστήματος write().Έπειτα, αφού τελειώσει την εγγραφή γίνεται με την remove_list() η αποδέσμευση της λίστας. Τέλος αφού ο Worker τελείωσε τη δουλειά του μέσω της kill() στέλνει στον εαυτό του το σήμα SIGSTOP, ώστε να μπλοκαριστεί και να ενημερώσει μέσω του σήματος τον  Manager ότι είναι διαθέσιμος και να τον προσθέσει στην ουρά. 

	Όταν τελειώσει ο Worker και μπλοκαριστεί με το σήμα SIGSTOP, ο Manager (γονική διεργασία) αυτόματα λαμβάνει σήμα SIGCHLD, όπου το σήμα αυτό δείχνει ότι κάποιο παιδί σταμάτησε ή τερματίστηκε στην περίπτωση μας σταμάτησε.Επιστρέφουμε στην αρχή του προγράμματος όπου είχαμε ορίσει έναν handler γι’ αυτό το σήμα.Με την sigaction εγκαθιστούμε ως χειριστής του σήματος SIGCHLD να είναι η συνάρτηση wait_sigchld().Η συνάρτηση wait_sigchld() αυτό που κάνει είναι με έναν βρόχο while να καλεί την κλήση waitpid() με ορίσματα options WNOHANG και  WUNTRACED, ώστε να βρίσκει ποια θυγατρική διεργασία τερματίστηκε ή σταμάτησε ( WUNTRACED ) και κάνοντας λήψη της κατάστασης της.Αν η κατάσταση δεν είναι άμεσα διαθέσιμη, να μην περιμένει ( WNOHANG ).
Η θυγατρική διεργασία τότε προστίθεται στο τέλος της ουράς (AddLast()).Με την λήψη του σήματος όμως η read() του  Manager μπλοκάρεται και γι’αυτό θέτουμε το errno=0, καθώς η τιμή του errno με το σήμα άλλαξε σε EINTR. 

Όταν ο χρήστης πληκτρολογήσει Ctrl-c παράγεται το σήμα SIGINT.Στην αρχή του προγράμματος έχουμε αναφέρει ότι έχουμε ορίσει έναν handler γι’ αυτό το σήμα.Με την sigaction εγκαθιστούμε ως χειριστής του σήματος SIGINT να είναι η συνάρτηση ctrl_c_fun().Η συνάρτηση ctrl_c_fun() αυτό που κάνει είναι με την Unlink_Fifo() να διαγράφει όλους τους επώνυμους αγωγούς που έχουν δημιουργηθεί.Έπειτα αφαιρεί έναν worker από την ουρα και με σήμα SIGKILL που στέλνει μέσω της kill() στο παιδί-worker το σκοτώνει.Η επιλογή του  SIGKILL γίνεται γιατί το μόνο σήμα που μπορούν να λάβουν οι “σταματημένες” διεργασίες είναι αυτό. Η διαδικασία γίνεται μέχρι η ουρά να αδειάσει.Τέλος αποδεσμεύω την ουρά και τερματίζω με EXIT_FAILURE.

Όλες οι κλήσεις συστήματος έχουν έλεγχο σφάλματος, αν οποιαδήποτε κλήση αποτύχει ενημερώνεται ο χρήστης και το πρόγραμμα τερματίζει.


---  Ζητούμενο 2:  ---


1. Τρέχω το shell script για παράδειγμα: ./finder.sh com uk org

2. -Περιγραφή Προγράμματος:
	
Ξεκινόντας έχω μια μεταβλητή dir στην οποία αποθηκεύω το μονοπάτι που βρίσκονται τα αρχεία που θα ψάξει ο finder για να βρει τα TLD.Έπειτα έχω έναν εξωτερικό βρόχο for που εξετάζω ένα ένα τα TLD που δοθηκαν στην γραμμή εντολών προς εξέταση.Αρχικά μέσα στο σώμα του βρόχου βρίσκω το μέγεθος του τρέχοντος TLD, ώστε να το χρησιμοποιήσω πιο κάτω για να απομονώσω τόσους χαρακτηρες στο τέλος του location που ελέγχω όσους έχει και το TLD προς εξέταση και μετά να συγκρίνω αν ταυτίζεται το TLD  με αυτους τους απομονωμένους χαρακτήρες.Ακολουθεί μια μεταβλητή counter_appear=0 όπου την αρχικοποιώ ίση με το 0 και σε αυτή θα προσθέτω το συνολικό πλήθος των εμφανίσεων του ζητούμενου TLD.Έπειτα ακολουθεί μια for loop όπου εξετάζει ένα ένα τα αρχεία του φακέλου που δώσαμε στην αρχή. Μέσα σε αυτόν τον εσωτερικό βρόχο με την εντολή locations=( $(cat ${dot_out_file}) ) αποθηκεύω στον πίνακα locations ολά τα δεδομένα του τρέχοντος αρχείου που βρίσκεται προς εξέταση.Ακολουθεί ένας τρίτος βρόχος εσωτερικά του δεύτερου όπου τώρα θα συγκρίνω  το TLD των locations με το TLD προς εξέταση που μας έδωσε ο χρήστης.Ο πίνακας location δεν αποθηκεύει γραμμή γραμμή αλλά συμβολοσειρα -συμβολοσειρά π.χ. di.uoa.gr 3 θα το αποθηκεύσει στον πίνακα locations[0]=”di.uoa.gr”    locations[1]=”3”.Γι αυτό έχω ορίσει η επανάληψη να γίνεται με βήμα +2 αφού όταν βρω πχ το TLD στο location που έχει αποθηκευτεί στην θέση i του πίνακα loacations λέω  num_of_appearances=location[i+1].Εσωτερικά στο σώμα του βρόχου βρίσκω το μέγεθος του location που εξετάσω loc_length=`expr length "${locations[i]}"`  μετά θέτω την μεταβλητή start=$(($loc_length-$tld_length)) , όπου βρίσκω από ποιά θέση του location θα αρχίσει η δέσμευση δηλαδή αν το μήκος του location είναι 5 και το ζητούμενο TLD έχει 3 γράμματα τότε λέω 5-3=2 ξεκίνα την δέσμευση από την θέση 2 του location.Στην συνέχεια στην μεταβλητή temp αποθηκεύω την συμβολοσειρά με τα απομονωμένα γράμματα  temp="${locations[i]:start:tld_length}" αν η temp είναι ίδια με το ζητούμενο TLD  ενεργοποιείται το flag για την προσθήκη του πλήθους των εμφανίσεων του  TLD.Η ίδια διαδικασία γίνεται μέχρι να εξεταστούν όλα τα location και αρχεία του καταλόγου.Τέλος εκτυπώνω το TLD με το πλήθος των εμφανίσεων του.