Κ24 ΠΡΟΓΡΑΜΜΑΤΙΣΜΟΣ ΣΥΣΤΗΜΑΤΟΣ:  2η Εργασία

Παναγιώτα Γύφτου,     Α.Μ. 1115201900318

Θα ήθελα να σας ενημερώσω ότι για την ουρά έχω χρησιμοποιήσει άσκηση από το μάθημα των Δομών Δεδομένων, την συγκεριμένη ουρά την έχω χρησιμοποιήσει και στην 1η εργασία (το έχω αναφέρει και στο README της 1ης εργασίας).Η ουρά είναι μια υλοποίηση ουράς διπλά συνδεδεμένης λίστας.Η άσκηση έχει γίνει εξ’ολοκλήρου από μένα.Τέλος τα ονόματα των συναρτήσεων είναι ίδια με αυτά που ζητούσε η εκφώνηση των Δομών Δεδομένων (και μόνο αυτά).Για οποιοδήποτε θέμα, εννοείται είμαι στην διάθεση σας.

Για την υλοποίηση της δικτυακής επικοινωνίας ανάμεσα στον πελάτη client ( όπου ο κώδικας του βρίσκεται στο αρχείο remoteClient.c) και στον εξυπηρετητή server ( dataServer.c) έχω χρησιμοποιήσει κώδικα από τις διαφάνειες του μαθήματος και συγκεκρίμενα από τις διαλέξεις του καθηγητή κύριου Αλέξανδρου Ντούλα.
Οι διαφάνειες είναι οι εξής:
	1. https://cgi.di.uoa.gr/~antoulas/k24/lectures/l10.pdf --->> p.31 & p.32 & p.33 & p.35 & p.36

Για την επικοινωνία των νημάτων και την ασφαλή πρόσβαση στην ουρά, χρησιμοποιώ κώδικα από τις διαφάνειες:
	1. https://cgi.di.uoa.gr/~antoulas/k24/lectures/l13.pdf --->> p.65 & p.66 & p.67

Για την αναδρομική ανάγνωση του καταλόγου, χρησιμοποιώ κώδικα από τις διαφάνειες:
	1. https://cgi.di.uoa.gr/~antoulas/k24/lectures/l06.pdf --->> p.37

Επίσης αναφέρω ότι έχω συμβολευτεί και το βιβλίο του μαθήματος "Προφραμματισμός σε UNIX, 2η Αμερικανική Έκδοση, Marc J. Rochkind"

					    ----------------------------------------------
						          Δομήση καταλόγου:
					    ----------------------------------------------

• Output/ -->>  Φάκελος στον οποίο θα τοποθετούνται τα ζητούμενα του πελάτη
• Server/ -->>  Περιέχει διάφορα αρχεία (όπως pdf, txt, docx,...) , υποκαταλόγους κλπ 
• src/    -->>  Ο πηγαίος κώδικας της εργασίας
• Makefile
• ParallelClients_script.sh
• README.txt


1. Οι εντολές μεταγλώττισης του προγράμματος βρίσκονται στο αρχείο Makefile, δηλαδή η μεταγλώττιση γίνεται με το make.

2. Και τρέχω το πρόγραμμα σε δύο κελύφη :
  
   α. στο πρώτο τρέχω τον εξυπηρετητή π.χ.: ./dataServer -p 12500 -s 5 -q 3 -b 2000
   
      (δηλ. port=12500, thread_pool_size=5, queue_size=3, block_size=2000)

   β. στο δεύτερο τρέχω ένα script με 10 πελάτες: ./ParallelClients_script.sh 127.0.0.1 12500
   
       ( δηλ. $1="127.0.0.1"(=server_ip) και $2="12500"(=server_port)
	
        ./remoteClient -i $1 -p $2 -d Server/floder1 &
        ./remoteClient -i $1 -p $2 -d Server &
	./remoteClient -i $1 -p $2 -d Server/floder2 &
	./remoteClient -i $1 -p $2 -d Server/floder3/floder3_3 &
	./remoteClient -i $1 -p $2 -d Server/floder2/floder2_2 &
	./remoteClient -i $1 -p $2 -d Server/floder1 &
	./remoteClient -i $1 -p $2 -d Server/floder3 &
	./remoteClient -i $1 -p $2 -d Server/floder3/floder3_2 &
	./remoteClient -i $1 -p $2 -d Server/floder3/floder3_2 &
	./remoteClient -i $1 -p $2 -d Server/floder3 &
       )

3. -Περιγραφή Προγράμματος:

---  dataServer  ---

	Ξεκινώντας την εκτέλεση του dataServer.c ελέγχω αν τα ορίσματα που δόθηκαν από τον χρήστη είναι σωστά και αν ναι τα αποθηκεύω σε μεταβλητές αλλιώς τερματίζω το πρόγραμμα ενημερώνοντας για το σφάλμα.Στην συνέχεια έχω τον signal handler για το σήμα SIGINT.Έπειτα ετοιμάζω τον υποδοχέα του εξυπηρετητή για να μπορεί να επικοινωνήσει με πελάτες.Το πρωτόκολλο επικοινωνίας πάνω από το δίκτυο που έχει εφαρμοστεί είναι το TCP/IP.Παράλληλα δημιουργώ την ουρά διπλά συνδεδεμένης λίστας και τους worker threads.Ακολουθεί ένας ατέρμονος βρόχος,στον οποίο το πρόγραμμα μπλοκάρεται περιμένοντας μια σύνδεση πελάτη.Όταν γίνει η σύνδεση, η accept() κλήση επιστρέφει τον περιγραφέα του υποδοχέα του πελάτη ο οποίος αποθηκεύεται στον πίνακα socket_descriptors ώστε όταν τερματιστεί το πρόγραμμα να κλείσω τον περιγραφέα αυτόν.Ο πίνακας socket_descriptors επεκτείνεται κάθε φορά που επιστρέφεται ένας περιγραφέας υποδοχής μετά από κάθε νέα σύνδεση.Έπειτα στέλνεται στον πελάτη το μέγεθος του block size, ώστε να ξέρει κάθε φορά πόσο μέγεθος θα διαβάζει από τον εξυπηρετητή όταν θα του στέλνεται το περιεχόμενο του αρχείου (θα αναλυθεί πιο κάτω).Ακολουθούν η δημιουργία δύων νημάτων, η δημιουργία του νήματος επικοινωνίας communication_thread και του νήματος διαχείρησης των worker νημάτων thread_pool.Οι συναρτήσεις εκκίνησης των νημάτων βρίσκονται στο αρχείο dataServer_Implementation.c (Η συνάρτηση του communication_thread είναι η Communication_Threads ενώ του thread_pool είναι η Thread_Pool).

- Communication_Threads:
	Αρχικά η συνάρτηση Communication_Threads() αυτό που κάνει είναι να διαβάζει από τον υποδοχέα του πελάτη το σχετικό μονοπάτι του φακέλου προς αντιγραφή που του έχει στείλει (ο περιγραφέας υποδοχής του πελάτη, έχει περαστεί στην Communication_Threads() ως όρισμα).Έπειτα ψάχνει και βρίσκει το απόλυτο μονοπάτι αυτού του σχετικού μονοπατιού.Το απόλυτο μονοπάτι του φακέλου Server που είναι ο φάκελος από τον οποίο ο πελάτης ζητάει μέσω του σχετικού μονοπατιού να αντιγραφεί κάποιος υποφάκελος του Server ή ακόμη και ο ίδιος ο Server, είναι γνωστό στον εξυπηρετητή.Επομένως, αφού βρεθεί το απόλυτο μονοπάτι του σχετικού path του ζητούμενου φακέλου, η Communication_Threads() καλεί την FnS_file_paths() για να σκανάρει αναδρομικά τον φάκελο που ζητήθηκε να αντιγραφεί, να βρεί και να αποθηκεύσει στην ουρά τα αρχεία που υπάρχουν μέσα σε αυτόν αλλά και αυτά των υποφακέλων του ( εαν έχει υποφακέλους).
	
	- FnS_file_paths():
		Αρχικά με την κλήση opendir() η FnS_file_paths() ανοίγει τον κατάλογο που της στάλθηκε, και ο δείκτης που επέστρεψε η κλήση, τον 	             χρησιμοποιούμε σαν όρισμα στην κλήση readdir(),η οποία καλείται σε έναν ατέρμονο βρόχο μέχρι να επιστρέψει NULL, δηλαδή μέχρι να φτάσει στο τέλος.Η 	        readdir() επιστρέφει έναν δείκτη σε δομή dirent, όπου από αυτήν θα βρίσκουμε το όνομα του τρέχοντος αρχείου ή καταλόγου.Έπειτα μέσα στο σώμα του 	        βρόχου φτιάχνουμε το απόλυτο μονοπάτι του τρέχοντος αρχείου, ώστε με την κλήση lstat() που ακολουθεί να πέρνουμε μια δομή από πληροφορίες γι' αυτό 	        το αρχείο.Στην συνέχεια με την χρήση της μακροεντολής ελέγχου S_ISDIR(mode) παίρνουμε την πληροφορία αν το αρχείο είναι κατάλογος ή απλό αρχείο.Εαν 	        είμαστε στην περίπτωση που το αρχείο είναι κατάλογος καλούμε ξανά αναδρομικά την FnS_file_paths() αυτή την φορά για το μονοπάτι του τρέχοντος 	             καταλόγου που βρέθηκε.Αν το αρχείο είναι ένα απλό αρχείο κλειδώνουμε ένα αντικείμενο αμοιβαίου αποκλεισμού,ώστε να ασφαλίσουμε ότι καμία άλλη 		        διεργασία δεν θα τροποποιήσει την ουρά μέχρι να τελειώσει η προσθήκη, εαν δεν είναι κλειδωμένο αλλιώς περιμένουμε να ξεκλειδωθεί.Στην συνέχεια 			ελέγχεται αν η ουρά είναι γεμάτη, αν είναι τότε μπλοκάρεται μέχρι η μεταβλητή συνθήκης Cond_nonFull (pthread_cond_wait (Cond_nonFull,Mutex) ) να 		λάβει σήμα από την κλήση pthread_cond_signal(&Cond_nonFull) όπου βρίσκεται στην συνάρτηση εκκίνησης Thread_Pool().Για να λάβει σήμα αρχικά πρέπει η 		pthread_cond_wait να μπλοκαριστεί και να ξεκλειδώσει το αντικείμενο αμοιβαίου αποκλεισμού, έτσι όταν αφαιρεθεί στοιχείο από την ουρά (από την 			Thread_Pool()) στέλνει σήμα ώστε να ενημερώσει ότι η ουρα δεν είναι πλέον γεμάτη. Μετά  ξανακλειδώνεται αυτόματα όταν επιστρέφει η 				pthread_cond_wait(), ξεμπλοκάρεται και συνεχίζουμε στην προσθήκη του αρχείου στην ουρά.Αφού τελειώσαμε με την προσθήκη και τη αποστολή του σήματος 		ότι η ουρά δεν είναι κενή (στο νήμα thread_pool), ξεκλειδώνουμε το αντικείμενο αμοιβαίο αποκλεισμού.


- Thread_Pool:
	Όλη η δουλειά της Thread_Pool() γίνεται σε έναν ατέρμονο βρόχο, μέσα στον οποίο αρχικά υπάρχει το αντικείμενο αμοιβαίου αποκλεισμού , το οποίο χρησιμοποιήθηκε στην συνάρτηση FnS_file_paths() του νήματος communication_thread.Εαν το αντικείμενο αμοιβαίου αποκλεισμού είναι κλειδωμένο τότε το thread_pool νήμα μπλοκάρεται μέχρι το αντικείμενο αμοιβαίου αποκλεισμού να ξεκλειδωθεί.Όταν ξεκλειδωθεί ή αν είναι ήδη ξεκλείδωτο τότε η Thread_Pool() το κλειδώνει, δηλαδή το χρησιμοποιεί για να ασφαλίσει την κρίσιμη περιοχή που διαχειρίζεται τα worker threads αλλά και την ουρά.Στην συνέχεια ελέγχει εαν η ουρά είναι κενή, αν είναι τότε τα worker threads περιμένουν μέχρι η μεταβλητή συνθήκης Cond_nonEmpty ( pthread_cond_wait(Cond_nonEmpty,Mutex) ) να λάβει σήμα από την κλήση pthread_cond_signal(&Cond_nonEmpty) όπου βρίσκεται στην συνάρτηση FnS_file_paths().Για να λάβει σήμα αρχικά πρέπει η pthread_cond_wait να μπλοκαριστεί και να ξεκλειδώσει το αντικείμενο αμοιβαίου αποκλεισμού, έτσι όταν προστεθεί στοιχείο στην ουρά στέλνει σήμα ώστε να ενημερώσει ότι η ουρα δεν είναι πλέον κενή. Μετά ξανακλειδώνεται αυτόματα όταν επιστρέφει η pthread_cond_wait(), ξεμπλοκάρεται και συνεχίζουμε στην αφαίρεση του πρώτου στοιχείου της ουράς, όπου το νήμα thread_pool αναθέτει σε έναν worker thread ένα αρχείο προς ανάγνωση.Η μεταβλητή w είναι μια ακέραια μεταβλητή ορισμένη ως extern, κατα την εκτέλεση του προγράμματος πριν γίνει οποιαδήποτε σύνδεση με πελάτη στην main η w αρχικοποιείται ίση με το 0.Για να αποφευχθεί κάποιο λάθος το w είναι ορατό από όλες τις κλήσεις Thread_Pool.Για κάθε κλήση Thread_Pool για χάρη καθε νέας σύνδεσης με έναν πελάτη, οι worker threads καλούνται κυκλικά, εάν πχ η πρώτη κλήση του Thread_Pool χρησιμοποιεί τον 1ο worker η δεύτερη χρησιμοποιεί τον 2ο και εαν η η πρώτη κλήση χρησιμοποιεί τον τελευταίο η δεύτερη χρησιμοποιεί τον πρώτο.Τέλος όταν τελειώσει το worker thread ξεκλειδώνεται το αντικείμενο αμοιβαίου αποκλεισμού.

	- Worker_Thread:
		Το πρώτο πράγμα που γίνεται στην συνάρτηση εκκίνησης Worker_Thread() είναι το άνοιγμα του αρχείου (open()) που ανέθεσε ο thread_pool στον 		τρέχον worker thread.Στην συνέχεια ο worker thread στέλνει στον πελάτη το όνομα του αρχείου.Έπειτα με την κλήση lseek() με pos=0 και με flag 		        SEEK_END επιστρέφεται το τέλος του αρχείου όπου έχει τιμή ίση με το μέγεθος του αρχείου.Πάλι με την κλήση lseek() με pos=-(την μεταβλητή που έχει 		αποθηκευτεί το μέγεθος του αρχειου) και με flag SEEK_CUR θέτω το αρχείο από την αρχή για την μελλοντική ανάγνωση.Η Worker_Thread() στέλνει το 		        μέγεθος του αρχείου στον πελάτη ως metadata, ώστε να υπολογίσει με βάση το block_size και το μέγεθος του αρχείου πόσες φορές θα διαβάσει την 		        υποδοχή.Στην συνέχεια το ίδιο κάνει και ο εξυπηρετητής, αφού στείλει το μέγεθος του αρχείου στον client, βρίσκει πόσες φορές θα γράψει στην                  υποδοχή.Τέλος γράφει ν φορές (όσες υπολόγισε) ανά block_size περιεχόμενο του αρχείου στην υποδοχή.


      
---  remoteClient  ---
	Ξεκινώντας την εκτέλεση του remoteClient.c ελέγχω αν τα ορίσματα που δόθηκαν από τον χρήστη είναι σωστά και αν ναι τα αποθηκεύω σε μεταβλητές αλλιώς τερματίζω το πρόγραμμα ενημερώνοντας για το σφάλμα.Έπειτα ετοιμάζω τον υποδοχέα του πελάτη για να μπορεί να επικοινωνήσει με τον εξυπηρετητή.Το πρωτόκολλο επικοινωνίας πάνω από το δίκτυο που έχει εφαρμοστεί είναι το TCP/IP.Το πρώτο πράγμα που κάνει ο πελάτης είναι να στείλει το σχετικό μονοπάτι στον εξυπηρετητή και στην συνέχεια διαβάζει από τον υποδοχέα το μήνυμα που του έστειλε ο εξυπηρετητής που είναι το block_size.Στην συνέχεια ο πελάτης μπαίνει σε έναν ατέρμονο βρόχο όπου αρχικά διαβάζει από τον υποδοχέα και περιμένει να του στείλει ο server το όνομα ενός αρχείου, αν τα bytes που διάβασε είναι 0 τότε ο εξυπηρετητής αποσυνδέθηκε που σημαίνει ότι τελείωσε την δουλειά του δεν έχει να του στείλει κάτι άλλο και έτσι ο client τερματίζει. Αν δεν είμαστε σε αυτή την περίπτωση τότε ο πελάτης διαβάζει για δεύτερη φορά τον υποδοχέα περιμένοντας το μέγεθος του αρχείου.Έχοντας σαν δεδομένα το μέγεθος του αρχείου και το block_size, όπως αναφέρθηκε και πιο πάνω ο πελάτης υπολογίζει πόσες φορές θα κληθεί η recv() και η write() αφού παράλληλα θα διαβάζει και θα γράφει τα περιεχόμενα του τρέχοντος αρχείου. Πριν όμως πάμε στην recv() και στην write(), ψάχνουμε αν στο μονοπάτι του αρχείου που μας δόθηκε υπάρχουν φάκελοι που πρέπει να φτιαχτουν, σίγουρα θα φτιαχτεί ο φάκελος που είναι προς αντιγραφή και αν το τρέχον αρχείο βρίσκεται σε υποκατάλογο/ους δημιουργείται/ούνται και αυτοί.Τέλος μεταβαίνουμε στην recv() και write() για την δημιουργία του αρχείου.


---  Ctrl-c  ---
	Όταν τελειώσει ο dataServer, δηλαδή όταν σταματήσει να εκτυπώνει ενημερωτικά μηνύματα πάει να πει ότι ολοκλήρωσε.Με Ctrl-c καλείται ο χειριστής,  αποδεσμεύεται η ουρά, κλείνουν οι περιγραφείς υποδοχής των πελατών, αποδεσμεύεται και ο πίνακας στον οποίο ήταν αποθηκευμένοι socket_descriptors αποδεσμεύεται ο πίνακας με τους worker threads, κάνουμε ξεκλείδωμα το αντικειμένου αμοιβαίου αποκλεισμού αν αυτό είναι κλειδωμένο ώστε να καταστρέψουμε τις μεταβλητές συνθήκης Cond_nonFull & Cond_nonEmpty.Έπειτα καταστρέφουμε το αντικείμενο αμοιβαίου αποκλεισμού , ελευθερώνουμε τον pointer pool_size και κλείνουμε τον περιγραφέα υποδοχής του εξυπηρετητή , τέλος τερματίζουμε το πρόγραμμα.Οι πελάτες ενημερώνονται για την αποσύνδεση και τερματίζουν και αυτοί. 

                                      ------------------------------------------------------------------
				 			 Πρωτόκολλο επικοινωνίας 
				      ------------------------------------------------------------------

             
                  ---  Client  ---                                                            ---  Server  ---   
                                
	     1. Αποστολή σχετικού μονοπατιού                             		   1. Αποστολή block_size
	     2. Ανάγνωση block_size					     		   2. Ανάγνωση σχετικού μονοπατιού  
             
	     while(1){                                                                      

	         3. Ανάγνωση ονόματος αρχείου (απόλυτο μονοπάτι αρχείου)                   3. Αποστολή ονόματος αρχείου (απόλυτο μονοπάτι αρχείου)
		 4. Ανάγνωση μέγεθος αρχείου                                               4. Αποστολή μέγεθος αρχείου
                
		 Υπολογισμός πλήθους επαναλήψεων ανάγνωσης                                 Υπολογισμός πλήθους επαναλήψεων ανάγνωσης 
                 (έστω ν επαναλήψεις)                                                      (έστω ν επαναλήψεις)
                 
                 for i = 0,...,ν do                                                        for i = 0,...,ν do
                     5. Ανάγνωση block_size περιεχόμενο   				       5. Αποστολή block_size περιεχόμενο 
                     write(block_size)                                                     end
                 end

	      }
                                                                                                       
                                                                          
	 



 Όλες οι κλήσεις συστήματος έχουν έλεγχο σφάλματος, αν οποιαδήποτε κλήση αποτύχει ενημερώνεται ο χρήστης και το πρόγραμμα τερματίζει.



  